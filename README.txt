Naive Preferences Solver__________________________________________________________________________________________________________________________________________________1. Introduction:The program is intended to model conditional and defeasible deontological evaluations and inferences. It reads sets of rules (R) from text files describing defeasible, conditional obligations and then calculates which worlds (i.e. truth assignments) are most preferable. The set of best worlds is used as a basis for making queries regarding additional (implied) obligations and permissions.   World preference is determined in terms of rule violation. A world w1 is preferable to w2 if and only if the set of rules violated in w1 is a subset of the rules violated in w2.Rules in the txt. files must be in the following format: (b, h), where a and b are formulas of propositional logic. "&" is used for "and", "|" is used for "or", and "~" is used for negation.		Example:	( (~P | (~Q | R)), (Q & P) )Constraints are formulas preceded by  an “!”		Example:	!(~C | ~F)Several example txt. files are included with the program.The program makes use of the sympy SAT solver, which requires mpath. It utilizes the sympy Symbol object, with which formulas are encoded for use with the SAT solver.2. Rules:The conditional nature of the rules is made evident in their form.  A rule is an ordered pair of propositional formulas (b, h), where the first item is the "body" and the second item is the "head". If the body is true then, all other things being equal, the head “should” also be true. The body is the condition, the obtaining of which renders the head obligatory unless the rule is defeated by another rule.Rule r is true at world w just in case both its body and head are true at w.Rule r is neutral at world just in case its body is false at w.Rule r is false at world w just in case its body is true in w but the head is false at w.If rule r is false at w and r is not defeated at w, then it is violated at w. Defeasibility is explained in the next section.The program can consider rule sets including unconditional obligations. To express an unconditional obligation, simply leave the body blank ( , h). h will be preferred no matter what else might be the case. 3. Domination:To make rules defeasible, it is necessary to provide conditions under which they may be overwritten or defeated by other rules. In general, rules with more specific bodies will dominate those with less specific bodies. Specificity, in turn, is understood in terms of material implication. Formula p is more specific than formula q just in case p implies q but q does not imply p. Rules, then, will typically be made more specific by adding conjuncts the body and are made less specific by adding disjuncts to the body. The formulas below become increasingly more specific from 1 to 5:	(1)	(p | q) | r	(2)	(p | q)	(3)	p	(4)	p & q	(5)	(p & q) & rThere is also a second condition if a rule r’ to dominate (overwrite) a rule r domination. To dominate r, r’ must be more specific and it must the be case that the heads of r and r’ cannot both be true. If the head of r’ does not essentially contradict the head of r, then it can hardly override r. If r is false at w and r’ dominates r, then r’ will override r just in case its body is true at w. In this case, r is said to be defeated by r’.It should be noted that if r’ is, in turn, defeated by r”, then r will no longer be defeated by r’ (unless, of course r” is defeated). The program searches for these cases recursively. 4. ConstraintsThe files read by the program may include constraints, requiring that a given formula should be true. The effect is that worlds that do not satisfy the constraint are excluded from consideration.Constraints can be used to enforce rules in which an exclusive disjunction is understood to hold or when evaluating a scenario in which some literals are supposed to be true. 5. Best WorldsThe best worlds are determined in terms of rule violations. For a world w, let w.F be the set of rules violated at w. A world w is among the best worlds just in case there does not exist a world w’ such that w’.F is a proper subset of w.F. 6. Inferred RulesThe set of best worlds is used to consider any rules that may be implied by those that are explicitly given in the text file. If W* is the set of best words given rule set R, then R implies rule r just in case W* is also the set of best world for R union {r}.   7. Inferred ImplicationsIn addition to checking whether a rule r is implied by R, the user can also check each of the following:(a) Given R, is it the case that 'a' obligates 'b'?(b) Given R, is it the case that 'a' makes 'b' permissible?a obligates b if the instances in which a is true within the best worlds W* are a subset of the instances in which b is true. In other worlds, whenever a is true in one of the best worlds, b is true a well.a makes b permissible just in case both a and b are true in at least one of the best worlds W*.__________________________________________________________________________________________________________________________________________________WARNING: The solver does not seem to like "N" or "S" for some reason, so do not use these in your rules or the program will likely crash.All lowercase letters appear to work fine as propositions.REMARK: Expressing preferences in propositional logic can be a bit tricky. For instance, suppose we want to encode the following preference: C > T > F.This can be expressed in the form of three rules:( ,  C)( ~C, T)(~(T | C), F)